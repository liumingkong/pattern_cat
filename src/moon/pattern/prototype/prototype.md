## prototype 原型模式

### 说明

```
   原型模式是从一个既有的对象克隆出一个新的实例。
   由于克隆操作往往会与特定的处理协议相关，实际项目中该模式由项目组骨干编写，要做到高效，安全而且克隆得要“像“需要相对较深的技术背景。
   有时候我们需要够早的不是只有初始状态的类型实例，而是需要构造与某个对象"当时"状态一样的实例。此时创建型模式就无能为力了。
```

### 经典原型模式的思路
* 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。
* 克隆的时候，克隆的可能只是局部对象，而不是全部对象。

### 什么时候会用到原型模式？
* 如果我们需要的类型不是编译态就已经明确的，而是运行过程中动态选择，为了不引入其他对象既可以继续创造出新对象，最简单的办法是直接对对象克隆。
* 如果我们需要的不是某个“初始状态”的对象，而是“恰巧”某个状态的对象。
* 枚举的某个状态很固定，但是实例固定，克隆其中一个状态。

### Object.clone 浅表复制
```
该方法执行的是浅表复制（Shallow Copy），该方法创建一个新对象，然后将当前对象的非静态字段（Filed，或成员）复制到新对象。
* 如果该字段是值类型，则对该字段执行逐位复制；
* 如果该字段是引用类型，则复制引用但不复制引用的对象（也就仅仅保存一个指针），因此，样本及其副本中引用型成员指向的是同一个对象。

这种复制是可期的，即一个实例哪些内容可以复制是可以预料的，实现上将栈内的逐位复制到一块新的空间，而堆中的内容不列入考虑。

```

### 项目中的原型类型

```
项目中，抽象工厂经常会集成原型类型，同时也有原型类型集成抽象工厂。
两个模式协作的目标是为了更好地解决“一系列”类型的构造过程，而且既可以满足于编译态要求，也能满足运行态要求。

综合原型模式
Client -> Abstract Factory -> Prototype1
						   -> Prototype2
				           -> ………
				           -> PrototypeN

抽象工厂模式				        
Client -> Prototype1 ->
       -> Prototype2 ->
       -> ………        -> Abstract Factory
       -> PrototypeN ->
       
* 如果一系列类型逐渐增多，用抽象工厂反而给自己增加了工作量，原因在于经典抽象工厂的功能是“僵化的”，增加新类型就要做修改，采用原形方法可以不把自己捆上，增加新类型，就让新增类型实现自己的clone()方法；
* 如果一系列对象的类型基本没有变化，对客户程序而言，使用抽象工厂仅仅需要依赖一个工厂对象，很简洁，不要求每个类型都自己实现clone方法。
```

### 深层拷贝

```
   Java的深层拷贝，即针对哪些引用类型另外开辟的一块内存，把引用目标地址的内容逐个位地复制一份，但可能会引发多层嵌套。为了满足深层复制的需要，可以在实现Cloneable接口的过程中进行定制化。
   通常有两种做法：
   * 手工逐层完成，要足够细心。
   * 序列化，无论是二进制序列化还是XML/SOAP序列化，Java的序列化其实提供了很大的灵活性，可以进行很细粒度的定制，编译器也会帮助对序列化过程进行一些检查，而且会沿着引用和继承关系一查到底。
```
##### 序列化方式的深层拷贝





